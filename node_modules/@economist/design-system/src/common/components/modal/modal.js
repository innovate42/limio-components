import React, { useCallback, useEffect, useRef } from 'react';
import PropTypes from 'prop-types';
import classNames from 'classnames';
import css from './modal.css';
import { keyValues } from '../../constants';

const Modal = ({
  showModal,
  onClose,
  width,
  ariaLabel,
  darkMode,
  children,
  className,
  ...otherProps
}) => {
  const FOCUSABLE_ELEMENTS_SELECTOR =
    'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])';

  const modalElement = useRef();

  const handleClickOutsideModal = useCallback(
    event => {
      if (!modalElement.current.contains(event.target)) onClose();
    },
    [modalElement],
  );

  const handleKeydown = event => {
    if (event.key === keyValues.ESC) onClose();

    /* unable to test as focus in Enzyme is not handled the same as in browser */
    /* istanbul ignore next */
    if (event.key === keyValues.TAB) {
      const focusableModalElements = modalElement.current.querySelectorAll(
        FOCUSABLE_ELEMENTS_SELECTOR,
      );

      if (focusableModalElements.length === 0) {
        event.preventDefault();
        return;
      }

      /* Identify last focusable element in the modal
    to keep tab keypresses within the modal and not the document underneath */
      const lastFocusableElement =
        focusableModalElements[focusableModalElements.length - 1];

      if (event.shiftKey && event.target === focusableModalElements[0]) {
        /* If user is focused on first focusable element and key presses to the previous element
            focus on last focusable element in modal */
        event.preventDefault();
        lastFocusableElement.focus();
      } else if (!event.shiftKey && event.target === lastFocusableElement) {
        /* If user is focused on last focusable element and keypresses to the next element
            focus on the modal */
        event.preventDefault();
        focusableModalElements[0].focus();
      }
    }
  };

  useEffect(() => {
    if (showModal) {
      const focusableModalElements = modalElement.current.querySelectorAll(
        FOCUSABLE_ELEMENTS_SELECTOR,
      );

      /* unable to test as focus in Enzyme is not handled the same as in browser */
      /* istanbul ignore next */
      if (focusableModalElements.length === 0) {
        modalElement.current.focus();
      } else {
        focusableModalElements[0].focus();
      }

      window.addEventListener('keydown', handleKeydown);
      document.addEventListener('click', handleClickOutsideModal, true);
      document.body.style.overflow = 'hidden';
    }

    return () => {
      window.removeEventListener('keydown', handleKeydown);
      document.removeEventListener('click', handleClickOutsideModal, true);
      document.body.style.overflow = 'visible';
    };
  }, [showModal, handleClickOutsideModal, modalElement.current]);

  if (!showModal) {
    return null;
  }

  return (
    <div
      className={classNames(css['ds-modal--container'], className)}
      {...otherProps}
    >
      <dialog
        open
        className={classNames(css['ds-modal'], [css[`ds-modal--${width}`]], {
          [css['ds-modal--dark-mode']]: darkMode,
        })}
        ref={modalElement}
        aria-modal='true'
        aria-label={ariaLabel}
        // eslint-disable-next-line jsx-a11y/no-noninteractive-tabindex
        tabIndex='0'
      >
        {children}
      </dialog>
    </div>
  );
};

Modal.defaultProps = {
  darkMode: false,
  className: '',
};

Modal.propTypes = {
  className: PropTypes.string,
  showModal: PropTypes.bool.isRequired,
  onClose: PropTypes.func.isRequired,
  width: PropTypes.oneOf(['small', 'medium', 'large']).isRequired,
  ariaLabel: PropTypes.string.isRequired,
  darkMode: PropTypes.bool,
};

export default Modal;
